// This code is copied from https://github.com/protocolbuffers/protobuf-go/tree/master
// due to private functions that are needed for field unmarshalling.
// Couldn't find any other way sadly

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by generate-types. DO NOT EDIT.

package reflection

import (
  "fmt"
	"math"

	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var errUnknown error = fmt.Errorf("unknown datatype when decoding raw proto value")
var errDecode error = fmt.Errorf("could not decode raw proto value")

// unmarshalScalar decodes a value of the given kind.
//
// Message values are decoded into a []byte which aliases the input data.
func UnmarshalScalar(b []byte, wtyp protowire.Type, fd protoreflect.FieldDescriptor) (val protoreflect.Value, n int, err error) {
	switch fd.Kind() {
	case protoreflect.BoolKind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfBool(protowire.DecodeBool(v)), n, nil
	case protoreflect.EnumKind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)), n, nil
	case protoreflect.Int32Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt32(int32(v)), n, nil
	case protoreflect.Sint32Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))), n, nil
	case protoreflect.Uint32Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfUint32(uint32(v)), n, nil
	case protoreflect.Int64Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt64(int64(v)), n, nil
	case protoreflect.Sint64Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)), n, nil
	case protoreflect.Uint64Kind:
		if wtyp != protowire.VarintType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfUint64(v), n, nil
	case protoreflect.Sfixed32Kind:
		if wtyp != protowire.Fixed32Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt32(int32(v)), n, nil
	case protoreflect.Fixed32Kind:
		if wtyp != protowire.Fixed32Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfUint32(uint32(v)), n, nil
	case protoreflect.FloatKind:
		if wtyp != protowire.Fixed32Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))), n, nil
	case protoreflect.Sfixed64Kind:
		if wtyp != protowire.Fixed64Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfInt64(int64(v)), n, nil
	case protoreflect.Fixed64Kind:
		if wtyp != protowire.Fixed64Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfUint64(v), n, nil
	case protoreflect.DoubleKind:
		if wtyp != protowire.Fixed64Type {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfFloat64(math.Float64frombits(v)), n, nil
	case protoreflect.StringKind:
		if wtyp != protowire.BytesType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfString(string(v)), n, nil
	case protoreflect.BytesKind:
		if wtyp != protowire.BytesType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfBytes(append(emptyBuf[:], v...)), n, nil
	case protoreflect.MessageKind:
		if wtyp != protowire.BytesType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfBytes(v), n, nil
	case protoreflect.GroupKind:
		if wtyp != protowire.StartGroupType {
			return val, 0, errUnknown
		}
		v, n := protowire.ConsumeGroup(fd.Number(), b)
		if n < 0 {
			return val, 0, errDecode
		}
		return protoreflect.ValueOfBytes(v), n, nil
	default:
		return val, 0, errUnknown
	}
}

func UnmarshalList(b []byte, wtyp protowire.Type, list protoreflect.List, fd protoreflect.FieldDescriptor) (n int, err error) {
	switch fd.Kind() {
	case protoreflect.BoolKind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfBool(protowire.DecodeBool(v)))
		return n, nil
	case protoreflect.EnumKind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfEnum(protoreflect.EnumNumber(v)))
		return n, nil
	case protoreflect.Int32Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt32(int32(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt32(int32(v)))
		return n, nil
	case protoreflect.Sint32Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt32(int32(protowire.DecodeZigZag(v & math.MaxUint32))))
		return n, nil
	case protoreflect.Uint32Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfUint32(uint32(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfUint32(uint32(v)))
		return n, nil
	case protoreflect.Int64Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt64(int64(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt64(int64(v)))
		return n, nil
	case protoreflect.Sint64Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt64(protowire.DecodeZigZag(v)))
		return n, nil
	case protoreflect.Uint64Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeVarint(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfUint64(v))
			}
			return n, nil
		}
		if wtyp != protowire.VarintType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeVarint(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfUint64(v))
		return n, nil
	case protoreflect.Sfixed32Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed32(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt32(int32(v)))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed32Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt32(int32(v)))
		return n, nil
	case protoreflect.Fixed32Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed32(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfUint32(uint32(v)))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed32Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfUint32(uint32(v)))
		return n, nil
	case protoreflect.FloatKind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed32(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed32Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed32(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfFloat32(math.Float32frombits(uint32(v))))
		return n, nil
	case protoreflect.Sfixed64Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed64(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfInt64(int64(v)))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed64Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfInt64(int64(v)))
		return n, nil
	case protoreflect.Fixed64Kind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed64(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfUint64(v))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed64Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfUint64(v))
		return n, nil
	case protoreflect.DoubleKind:
		if wtyp == protowire.BytesType {
			buf, n := protowire.ConsumeBytes(b)
			if n < 0 {
				return 0, errDecode
			}
			for len(buf) > 0 {
				v, n := protowire.ConsumeFixed64(buf)
				if n < 0 {
					return 0, errDecode
				}
				buf = buf[n:]
				list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
			}
			return n, nil
		}
		if wtyp != protowire.Fixed64Type {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeFixed64(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfFloat64(math.Float64frombits(v)))
		return n, nil
	case protoreflect.StringKind:
		if wtyp != protowire.BytesType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfString(string(v)))
		return n, nil
	case protoreflect.BytesKind:
		if wtyp != protowire.BytesType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return 0, errDecode
		}
		list.Append(protoreflect.ValueOfBytes(append(emptyBuf[:], v...)))
		return n, nil
	case protoreflect.MessageKind:
		if wtyp != protowire.BytesType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeBytes(b)
		if n < 0 {
			return 0, errDecode
		}
		m := list.NewElement()
		if err := proto.Unmarshal(v, m.Message().Interface()); err != nil {
			return 0, err
		}
		list.Append(m)
		return n, nil
	case protoreflect.GroupKind:
		if wtyp != protowire.StartGroupType {
			return 0, errUnknown
		}
		v, n := protowire.ConsumeGroup(fd.Number(), b)
		if n < 0 {
			return 0, errDecode
		}
		m := list.NewElement()
		if err := proto.Unmarshal(v, m.Message().Interface()); err != nil {
			return 0, err
		}
		list.Append(m)
		return n, nil
	default:
		return 0, errUnknown
	}
}

func UnmarshalMap(b []byte, wtyp protowire.Type, mapv protoreflect.Map, fd protoreflect.FieldDescriptor) (n int, err error) {
	if wtyp != protowire.BytesType {
		return 0, errUnknown
	}
	b, n = protowire.ConsumeBytes(b)
	if n < 0 {
		return 0, errDecode
	}
	var (
		keyField = fd.MapKey()
		valField = fd.MapValue()
		key      protoreflect.Value
		val      protoreflect.Value
		haveKey  bool
		haveVal  bool
	)
	switch valField.Kind() {
	case protoreflect.GroupKind, protoreflect.MessageKind:
		val = mapv.NewValue()
	}
	// Map entries are represented as a two-element message with fields
	// containing the key and value.
	for len(b) > 0 {
		num, wtyp, n := protowire.ConsumeTag(b)
		if n < 0 {
			return 0, errDecode
		}
		if num > protowire.MaxValidNumber {
			return 0, errDecode
		}
		b = b[n:]
		err = errUnknown
		switch num {
		case 1:
			key, n, err = UnmarshalScalar(b, wtyp, keyField)
			if err != nil {
				break
			}
			haveKey = true
		case 2:
			var v protoreflect.Value
			v, n, err = UnmarshalScalar(b, wtyp, valField)
			if err != nil {
				break
			}
			switch valField.Kind() {
			case protoreflect.GroupKind, protoreflect.MessageKind:
		    if err := proto.Unmarshal(v.Bytes(), val.Message().Interface()); err != nil {
					return 0, err
				}
			default:
				val = v
			}
			haveVal = true
		}
		if err == errUnknown {
			n = protowire.ConsumeFieldValue(num, wtyp, b)
			if n < 0 {
				return 0, errDecode
			}
		} else if err != nil {
			return 0, err
		}
		b = b[n:]
	}
	// Every map entry should have entries for key and value, but this is not strictly required.
	if !haveKey {
		key = keyField.Default()
	}
	if !haveVal {
		switch valField.Kind() {
		case protoreflect.GroupKind, protoreflect.MessageKind:
		default:
			val = valField.Default()
		}
	}
	mapv.Set(key.MapKey(), val)
	return n, nil
}

// We append to an empty array rather than a nil []byte to get non-nil zero-length byte slices.
var emptyBuf [0]byte

